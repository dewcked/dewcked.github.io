---
layout: post
title: "운영체제1"
comments: true
category: U-operating-system
---

## 운영체제

하드웨어를 관리하고 어플리케이션 프로그램들이 실행되는 환경을 제공해주는 소프트웨어  리소스를 할당하고, 프로그램을 컨트롤한다.

### 부트스트랩 프로그램 (펌웨어)

ROM 또는 EEPROM에 저장되어 운영체제를 불러온다.

### 인터럽트

운영체제는 인터럽트에 의해 움직인다(interrupt-driven)

소프트웨어가 발생시킨 인터럽트 = 시스템 콜 = 트랩(trap)

### 소프트웨어 실행 사이클

1. 프로그램 로드
2. 명령어 페치(Fetch, 읽기)
3. 명령어 디코딩(해석)
4. 오퍼랜드 페치
5. 명령어 실행
6. 결과 저장
7. (2로 돌아가 반복)

### 저장공간

>**(비용▲ 속도▲ volatile)**
>
>레지스터
>
>캐시
>
>메인 메모리
>
>전기 디스크
>
>자기 디스크
>
>옵티컬 디스크
>
>자기 테이프
>
>**(비용▼ 속도▼ non-volatile)**

### I/O 구조?

각각의 I/O 디바이스는 로컬 버퍼를 가진다.

보통 I/O 디바이스 드라이버에서 인터럽트를 발생시켜 CPU와 I/O 디바이스 사이에서 데이터 이동이 일어난다.

### DMA (Direct Memory Access)

CPU를 거치는 인터럽트가 너무 많이 발생할 경우 오버헤드가 커진다.

그래서 I/O 장치에서 CPU를 거치지 않고 바로 블록 단위로 입출력하는 인터럽트를 발생시킨다.

### 오버헤드

낭비되는 메모리나 속도 등을 의미한다.

### 커널 모드

커널 실행 모드

### 유저 모드

유저 실행 모드

 * 타이머의 값 설정 - 커널 모드
 * 시계 읽기 - 유저 모드
 * 인터럽트 종료 - 커널 모드
 * I/O 디바이스 접근 - 커널 모드
 * trap 명령어 발동 - 유저 모드

## 운영체제의 역할

### 프로세스 관리

 * 프로세스와 스레드의 스케쥴링 (cpu)
 * 유저와 시스템의 프로세스를 만들어나 제거
 * 프로세스를 중단하거나 재개하는 역할
 * 프로세스 synchronization과 프로세스 communication을 위한 매커니즘을 배포

### 메모리 관리

 * 메모리 상의 다음 실행될 명령어들 전부
 * 메모리 상의 모든 데이터
 * cpu를 최적화하기 위해 메모리에 상주한 여러 프로그램들
 * 메모리 추적 관리
 * 어느 프로세스의 메모리를 할당하고 해제할 것인지 결정
 * 메모리 할당과 해제

### 저장공간 관리

 * 파일 시스템 관리
 * 복잡한 저장공간 관리
 * 캐싱
 * I/O 서브시스템

### 보호와 보안

 * 보호: 유저id 그룹id
 * 보안: password

### 운영체제 서비스

 * 유저 인터페이스
 * 프로그램 실행
 * I/O 동작
 * 파일 시스템 관리
 * 커뮤니케이션
 * 에러 디텍션
 * 리소스 할당
 * 어카운팅
 * 보호 & 보안

### 시스템 콜 파라미터 전달

 * 레지스터에 넣어 전달
 * 메모리상의 블록에 전달하고 레지스터로 주소 전달
 * 스택에 저장하고, 운영체제에서 POP

### 시스템 콜 정의 과정

a. 함수 정의

```c
asmlinkage long sys_helloworld(void){
printk("Hello, World !!!\n");
}

```

b. 번호 할당

```c
#define __NR_helloworld 223

```

c. 함수 등록

```c
ENTRY(sys_call_table)
	.long sys_~~~~~~
    .long sys_~~~~~~
    .long sys_helloworld

```

d. 커널 리빌드, 테스트 (syscall 호출)

```c
_syscall0(int, helloworld);
int main(void)
{
	helloworld();
}

```

## 운영체제 구조

### Monolithic 구조

운영체제 등 소프트웨어의 레벨이 구체적으로 정의되지 않음

MS-DOS, 전통적인 UNIX 시스템

구조를 파악하는데 어려움이 있음

### Layered approach

붙어있는 껍질끼리만 데이터 전송이 가능
 
다양한 구조를 표현하는데 한계가 있고, 오버헤드가 많이 발생

### Microkernels

커널의 영역을 최대한 축소

메세지 패싱 방식을 이용해서 유저 모듈끼리 통신한다.

메세지 패싱 오버헤드가 발생

### Modules

OS - 다수의 모듈 - 유저 어플리케이션 구조

모듈끼리 메세지 패싱이 필요없고, 서로 인터페이스를 통해 통신이 가능하다.

# 프로세스

### 프로세스 구조

 * TEXT
 * 프로그램 카운터
 * STACK
 * DATA
 * HEAP

### I/O-bound 프로세스

I/O 작업 위주

### CPU-bound 프로세스

CPU 연산 작업 위주

### 프로세스 작업 주기

 * 새로 만들어진 상태 - New
 * 실행 중 상태 - Running
 * 기다리는 중 상태 - Waiting
 * 준비 상태 - Ready
 * 종료 상태 - Terminated

### PCB: 프로세스 컨트롤 블럭

저장되는 정보

 * 프로세스 상태
 * 프로그램 카운터
 * CPU 레지스터
 * CPU 스케쥴링 정보
 * 메모리 관리 정보
 * 어카운팅 정보
 * I/O 상태 정보

## 프로세스 스케쥴링 큐

### Job 큐

모든 프로세스가 담겨 있다.

### 레디 큐

메인 메모리의 모든 프로세스가 담겨 있다.

### 디바이스 큐

I/O 작업을 위해 기다리는 중인 프로세스가 담겨 있다.

## 스케쥴러

### long-term 스케쥴러 (Job 스케쥴러)

어떤 프로세스가 레디 큐로 들어와야 하는지 선택한다.

멀티프로그래밍의 수준을 결정한다.

### short-term 스케쥴러 (CPU 스케쥴러)

어떤 프로세스가 실행되고 메모리를 할당받아야 하는지 선택한다.

### mid-term 스케쥴러

어떤 프로세스가 스와핑(Swapped out/in) 되어야 하는지 선택한다.

### 컨텍스트 스위치

프로세스끼리 실행상태를 바꾸는 것

## 프로세스의 동작

### 프로세스 생성

pid - 프로세스 고유 id

부모 프로세스 - 루트 프로세스

자식 프로세스 - 부모로부터 파생된 프로세스

### 리소스 공유 모드

 a) 부모와 자식 프로세스가 모든 리소스 공유
 
 b) 자식이 부모의 일정 부분을 공유
 
 c) 공유하지 않음

### 실행 모드

 a) 부모와 자식이 동시에 실행중인 상태
 
 b) 부모가 자식이 실행중인 동안 중지

### 주소공간 모드

 a) 자식이 부모의 복사본
 
 b) 자식이 그 주소에 새롭게 로드된 프로그램

### 유닉스

 * 부모: fork() -> (child process 생성) -> wait -> (child process 종료) -> resumes
 * 자식: exec() -> exit()

```c
int main()
{
	pid_t pid;
    /*fork another process */

    pid = fork();
    if(pid<0){
    fprintf(stderr, "Fork error ...\n");
    exir(-1);
    }
    else if(pid == 0){ /* child process */
    execlp("/bin/ls", "ls", NULL);
    }
    else {  /*parent process */
    	/*parent process will wait for the child process to complete */
        wait(NULL);
        printf("Child Completed ...\n");
        exit(0);
    }
}

```

## 프로세스 종료

 * 시스템에게 exit 호출해서 지워달라고 요청하면 시스템이 지워줌
 * abort를 이용하면 부모 프로세스에서 자식 프로세스를 종료
  * 자식이 리소스 용량 초과
  * 자식이 더이상 작업에 필요하지 않음
  * 부모가 종료될 때

### Cascaded termination

부모가 종료될때 부모의 프로세스 트리 모두 종료

## IPC: Inter-Process Communication

independent 프로세스: 독립적

cooperating 프로세스: 다른 프로세스에 영향을 줌

 * 목적: 정보 공유, 계산속도 향상, 모듈화, 편리성

## IPC 모델

### 공유 메모리(Shared memory)

Synchronization 문제 발생

### 메세지 패싱(Message Passing)

send와 recieve를 통한 메세지 교환

 * blocking (synchronous)
  * send가 메세지가 recievㄷ될때까지 sender block을 가지고 있음
  * recieve가 메세지가 가능할 때까지 reciever block을가지고 있음
 * non-blocking
  * send가 sender를 가지고 있음
  * recieve가 reciever를 가지고 있음

>메세지 패싱 구현의 방법론
>
>링크가 어떻게 설정되는가
>
>링크가 두 개 이상의 프로세스에 의해 연결될 수 있나
>
>모든 각각의 communicating 프로세스에 대해 얼마나 많은 링크가 존재하는가
>
>링크의 capacity란
>
>링크가 처리할 수 있는 메세지의 크기는 고정되어있는가
>
>링크가 단방향인가 쌍방향인가
>

### Direct Communication

 * 프로세스가 서로를 뚜렷하게 이름을 붙여주어야 한다.
 * send(P, message) - 프로세스 P에게 message를 보낸다
 * recieve(Q, message) - 프로세스 Q로부터 message를 받는다
 * 링크의 속성
  * 자동 연결
  * 한 쌍의 communicating 프로세스에 대해서만 연결
  * 한 쌍의 프로세스는 한 개의 링크
  * 단방향일수도, 쌍방향일수도 있음

### Indirect Communication

 * 굳이 이름을 붙여주지 않아도 메세지가 메일박스 (포트)를 통해 전달됨
 * 각각의 메일박스는 고유id가 있음
 * 메일박스를 공유할 때만 링크가 설정되어 서로 communicating 가능
 * 링크가 많은 프로세스끼리 연결 가능
 * 각 쌍의 프로세스는 여러 communication 링크를 가질 수 있다
 * 단방향일수도, 쌍방향일수도 있음
 * 작동방식
  * 메일박스를 만든다
  * 메세지를 주고받는다
  * send(M, message) : 메일박스 M에 메세지를 보냄
  * recieve(M, message) : 메일박스 M으로부터 메세지를 받음
  * 만약 동시에 받게될 경우는 전부 받을지, 하나만 받을지, 보내는사람이 선택하도록 알려줄지 구현 가능
  * 메일박스를 제거한다

### 버퍼링(Buffering)

링크에 붙은 메세지의 큐

 * Zero capacity - 0 메세지
 * sender가 reciever를 위해 기다려야됨
 * bounded capacity - infinite length of n messages
 * sender가 큐가 가득찼다면 기다려야 됨
 * unbounded capacity - infinite length
 * sender가 기다리지 않음

## 클라이언트-서버 간의 통신

### 소켓

communication의 엔드포인트

IP 주소와 포트의 연결체

### 리모트 procedure 콜

별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다.

다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.

* Stub
 * 클라이언트-사이드 프록시
 * ... (안해도됨)

## 파이프

### 파이프 - 방향성

크게 단방향(방향성이 있음)과 쌍방향(방향성이 없음)으로 나누어진다.

### 파이프 - 데이터 전송 방식

half duplex: 한 번에 send나 recieve중 하나만 할 수 있다.

full duplex: send를 하면서 recieve 도 가능하다.

### 파이프 - 네트워크에 따라

글로벌 네트워크에서의 파이프와 로컬 네트워크 안의 파이프로 나누어진다.

### ordinary (anonymous) 파이프

* 두 프로세스끼리만 통신하도록 하는 파이프
* 쌍방향(방향성이 없다)
* 프로세스간 통신이 끝나면 파이프가 닫힌다
* 파이프를 만든 프로세스 바깥에서는 접근 불가
* 보통 부모가 자식과 통신할때 쓴다

### named 파이프

* 여러 프로세스가 커뮤니케이팅에 사용 가능하다
* 쌍방향(방향성이 없다)
* 프로세스간 통신이 끝나도 계속 존재
* 부모-자식간 관계 필요없음

### 파이프와 메세지 패싱의 차이점

파이프: bit 단위로 스트림을 보낸다 (비트스트림)

메세지 패싱: 메세지를 구조화해서 보낸다. (Structured Message)

### Get/Set Priority

### Get ID

### Get PCB

## 쓰레드

 * CPU utilization 의 기본 단위
 * 쓰레드 ID, 프로그램 카운터, 레지스터 셋, 스택을 COMPRISE
 * 같은 프로세스의 다른 쓰레드와 자원을 공유

### 쓰레드의 장점

 * 반응성
 * 자원 공유 (구현의 용이성 측면)
 * 경제적 (메모리 할당 측면)
 * Scalability (멀티 cpu에서 멀티 쓰레딩)

```c
#include <pthread.h>
#include <stdio.h>

int sum; /* this data is shared by the threads */
void *runner(void *param);

int main(int argc, char *argv[])
{
    pthread_t tid;
    pthread_attr_t attr;

    pthread_attr_init(&attr);	/* get the default attributes */
    pthread_create(&tid, &attr, runer, argv[1]);	/* create a thread */
    pthread_join(tid, NULL);	/* wait for the thread to exit */

    printf("SUM = %d\n", SUM);
}

/* The thread will begin control in this function */
void *runner(void * param)
{
    int i, upper = atoi(param);
    sum = 0;

    for(i =1; i <= upper; ++i)
        sum += 1;

    pthread_exit(0);
}

```

# 멀티코어 프로그래밍

싱글코어 프로그램에서 쓰레드 실행

 * T1 - T2 - T3 - T4 - T1 - T2 - T3 - T4 - ...

멀티코어 프로그램에서 쓰레드 실행

 * T1 - T3 - T1 - T3 - ...
 * T2 - T4 - T2 - T4 - ...

### 유저 쓰레드

 * 유저 레벨 쓰레드 라이브러리에 의해 관리
 * ex ) POSIX Pthread, Win32 thread, Java thread

### 커널 쓰레드

 * 운영체제에 의해 관리
 * ex ) Windows XP/2000, Solaris, Linux, Mac OS X

## 멀티쓰레딩 모델

### Many-to-One 모델

많은 유저 레벨 쓰레드가 하나의 커널 쓰레드로 매핑

유저 쓰레드에 의해 관리됨

만약 쓰레드가 blocking 시스템 콜을 호출 시 모든 프로세스가 block됨

### One-to-One 모델

각각의 유저 레벨 쓰레드가 각각의 커널 쓰레드로 매핑

오버헤드가 매우 커짐

### Many-to-Many 모델

많은 유저 레벨 쓰레드가 적거나 같은  수의 커널 쓰레드로 매핑

### Two-level 모델

Many-to-Many + One-to-One

## 쓰레드 라이브러리

구현 방법

 * 유저 스페이스에 라이브러리 전부 구현
 * 커널 레벨 라이브러리가 운영체제에 의해 지원

### Pthread

 * 쓰레드 생성과 씽크로를 `POSIX standard (IEEE 1003.1c)` 로 구현
 * API가 쓰레드 라이브러리의 동작을 정함 (라이브러리에 달려있음)
 * 유저레벨이나 커널레벨

### Java Thread

 * JVM에 의해 관리
 * 운영체제에 의해 지원되는 전형적인 쓰레드 모델

### 쓰레딩 구현 문제

 * fork() exec 시스템 콜의 semantics
 * 타겟 쓰레드의 쓰레드 종료 (Asynchronous or deferred)
 * 시그널 핸들링
 * 쓰레드 풀
 * 쓰레드-specific 데이터
 * 스케쥴러 행위 (Many-to-Many and Two-level model)

# 스케쥴링

멀티프로그래밍을 통해 CPU를 최적화 가능

실행할 준비가 된 프로세스들에 CPU를 할당해 줌

### 멀티프로그래밍

한개 프로세스 안의 CPU 연산 작업과 I/O 작업은 동시에 이루어질 수 없기 때문에 둘을 적절히 분배하여 CPU가 쉬지 않게 한다.

### 타임쉐어링 (멀티태스킹)

멀티프로그래밍을 여러 개의 프로세스에 적용시킨 것으로, 여러 개의 프로세스가 돌아가면서 CPU를 할당받는다.

### Job 스케쥴링

프로세스가 메모리에 불러질때

### CPU 스케쥴링

프로세스가 실행될 때

### Swapping

프로세스의 실행 상태를 바꿈

### 가상메모리

메모리가 부족할 때

다음의 경우 스케쥴링이 필요

1. running -> waiting (I/O request)
2. running -> ready (interrupt)
3. waiting -> ready (I/O completion)
4. Terminates

1, 4번에 기반하여 스케쥴링을 구현: nonpreemptive

2, 3번에 기반하여 스케쥴링을 구현: preemptive (coorperative)

### nonpreemptive

프로세스에 작업이 할당되면 끝날때까지 다른 프로세스로 넘어가지 않음

### preemptive

프로세스에 작업이 할당되어도 스케쥴러에 의해 다른 프로세스로 넘어감 (타이머 필요)

사용에 주의하지 않으면 synchronization 문제(데이터 불일치)가 발생함

## 디스패쳐(Dispatcher)

콘텍스트 스위치

유저 모드로 스위치

프로그램 재시작을 위해 적당한 위치로 점프

### 디스패치 latency

어떤 프로세스를 종료하고 다른 프로세스가 시작될때까지의 딜레이 시간

## 스케쥴링 Criteria

### CPU 최적화

항상 CPU를 바쁘게 만든다

### Throughput

한 타임 유닛에 실행이 완료되는 프로세스의 갯수

### Turnaround time

한 프로세스가 온전하게 실행이 완료될때까지 걸리는 시간

### Waiting time
프로세스가 로드된 후 실행되기까지 기다린 시간

### Response time

요청이 전달되고 첫 응답이 생산되기까지 걸리는 시간 (멀티태스킹 환경)

## 스케줄링 알고리즘

### FCFS (First-Come, First-Served) 스케쥴링

![sch_FCFS](/images/sch_FCFS.JPG "FCFS")

nonpreemptive 방식으로 동작한다.

프로세스의 Waiting time

 * p1 = 0
 * p2 = 24
 * p3 = 27

평균 Waiting time = (0 + 24 + 27) / 3 = 17

![sch_FCFS2](/images/sch_FCFS.JPG "FCFS")

도착하는 순서가 바뀌었으므로

프로세스의 Waiting time

 * p1 = 6
 * p2 = 0
 * p3 = 3

평균 Waiting time = (6 + 0 + 3) / 3 = 3

콘보이 효과(Convoy effect)가 발생
 * 큰 프로세스가 작업을 전부 처리할 동안 다른 프로세스들은 기다려야됨

### SJF(Shortest-Job-First) 스케쥴링

콘보이 효과를 방지하기 위해 만들어졌다.

<1> nonpreemptive 방식의 SJF

![sch_SJF](/images/sch_SJF.JPG "SJF")

burst time을 기준으로 제일 빠른것부터 채워넣는다.
*만약 burst time이 같을 경우, 먼저 도착한 것부터 넣는다.

`위 그림에서 Arrival Time을 생각하지 않은 프로세스의 Waiting time`

 * p1 = 3
 * p2 = 16
 * p3 = 9
 * p4 = 0

평균 Waiting time = (3 + 16 + 9 + 0) / 4 = 7


`위 그림에서 Arrival Time을 생각한 프로세스의 Waiting time`

 * p1이 먼저 도착하게 되므로 p1을 burst한다 (시간 6 경과)
 * p1이 burst되는 동안 p2, p3, p4가 전부 도착하므로(Arrival time이 각각 2, 4, 5) 이 중 burst time이 짧은 것부터 순서대로 큐에 넣는다.
 * (순서 = p1 - p4 - p3 - p2)

프로세스의 Waiting time

 * p1 = 0
 * p2 = 16
 * p3 = 9
 * p4 = 6

평균 Waiting time = (0 + 16 + 9 + 6) / 4 = 7.75

**Arrival time은 프로세스가 로드가 끝난 시간을 의미한다.**

<2> preemptive 방식의 SJF

![sch_SJF2](/images/sch_SJF2.JPG "SJF")

 * p1이 먼저 도착한 뒤 1초동안 burst한다.
 * p2가 도착한 뒤에 p1의 남은 burst time보다 p2의 birst time이 작으므로 p1을 중지하고 p2를 burst한다.
 * 2초에 p3이 도착했지만 burst time은 p2가 여전히 p3보다 작아 p2 계속 진행
 * 3초에 p4가 도착했지만 burst time은 p2가 여전히 p4보다 작아 p2 계속 진행
 * 5초가 되면 p2는 4초의 모든 burst time이 끝나게 된다.
 * 각각 프로세스에 대해 남은 burst time은 p1 7초, p3 9초, p4 5초가 남게 되므로 p4를 실행한다.
 * p4 실행이 끝나고 다음으로 작은 burst time을 가진 p1이 실행된다.
 * 마지막으로 p3이 실행되고 프로그램이 종료된다.

프로세스의 Waiting time

 * p1 = 10(p1 마지막 실행 블록 시작점) -1(p1 그전의 burst time) - 0(p1 arrival time) = 9
 * p2 = 1(p2 마지막 실행 블록 시작점) -1(p2 arrival time) = 0
 * p3 = 17(p3 마지막 실행 블록 시작점) - 2(p3 arrival time) = 15
 * p4 = 5(p4 마지막 실행 블록 시작점) - 3(p4 arrival time) = 2

평균 Waiting time = (9 + 0 + 15 + 2) / 4 = 6.5

preemptive SJF 방식은 optimal (최적) - 프로세스 처리 시간이 평균을 유지한다.

실제 burst time의 계산은 유저가 정해준 값이나 과거의 히스토리로부터 명령어 길이를 유추한다.

### Priority 스케쥴링

![sch_priority](/images/sch_priority.JPG "priority")

우선순위(priority)에 따라 실행된다.

프로세스의 Waiting time

 * p1 = 6
 * p2 = 0
 * p3 = 16
 * p4 = 18
 * p5 = 1

평균 Waiting time = (6 + 0 + 16 + 18 + 1) / 5 = 8.2

starvation 문제(우선순위가 낮은 프로세스가 계속 실행되지 않는 문제)를 방지하기 위해 aging 도입

aging: 우선순위가 낮은 프로세스의 우선순위를 시간이 지남에 따라 높여주어 starvation 방지

### RR (Round-Robin) 스케쥴링

![sch_RR](/images/sch_RR.JPG "Round Robin")

p1, p2, p3 순서로 실행되는데 각각 최대 Time Quantum 만큼의 시간만 할당받아서 최대 그 시간 만큼만 실행된다.

burst time이 time Quantum보다 작을경우는 burst time 내에서 처리한다.

![sch_RR_quantum1](/images/sch_RR_quantum.JPG "Round Robin")

이 모델에 대해서는 Context Switch와 Turnaround time이 주로 언급된다.

Context Switch는 프로세스를 swap하는 행위로, 많이 일어날수록 오버헤드가 커지게 된다.

![sch_RR_quantum2](/images/sch_RR_quantum2.JPG "Round Robin")

Turnaround time은 어떤 프로세스가 로드된 때로부터 실행이 완료될때까지 걸린 시간이다.ㅏ

time quantum(q)의 값이 1일 때 turnaround time은

 * p1 28
 * p2 29
 * p3 30
 
평균 turnaround time = (28 + 29 + 30) / 3 = 29

time quantum(q)의 값이 10일 때 turnaround time은

 * p1 10
 * p2 20
 * p3 30

평균 turnaround time = (10 + 20 + 30) / 3 = 20

time quantum 값을 너무 작게 설정할 경우 오버헤드가 커지고 처리시간이 오히려 느려진다.

### Multilevel Queue 스케쥴링

![sch_MQ](/images/sch_MQ.JPG "Multilevel Queue")

priority가 높은 큐부터 처리를 한다.

starvation 문제가 여전히 발생(아래쪽의 큐는 우선순위가 낮기 때문!)

### Multilevel FeedBack Queue 스케쥴링

![sch_MFQ](/images/sch_MFQ.JPG "Multilevel FeedBack Queue")

위의 starvation 문제를 해결한 모델로 일정 시간마다 큐를 돌아가면서 실행한다.

큐마다 스케쥴링 구조가 다를 수 있다.
