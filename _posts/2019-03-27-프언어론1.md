---
layout: post
title: "프언어론1"
comments: true
category: U-programming-language
---

## 언어론

##### 컴파일러 <-> 중간모델 <-> 인터프리터
해석(interprete)은 프로그래머가 작성한 코드를 해석기(interpreter)가 읽는 즉시 바로 해석하여 실행하는 방식이고, 컴파일(compile)은 프로그래머가 작성한 코드를 컴파일러(compiler)가 목적 프로그램(윈도우의 경우 PE 포맷, 리눅스는 ELF 포맷) 기계어 코드로 변환한 뒤 기계어를 실행하는 방식이다. 해석은 생각한것을 즉시 실행하여 좀더 프로그래머에게 친숙한 언어라는 장점이 있고, 컴파일에 걸리는 시간이 적을 경우 컴파일은 프로그램의 실행 속도가 해석보다 빠르다는 장점이 있으나 컴파일에 걸리는 시간이 클 경우에는 해석이 더 나은 퍼포먼스를 보이기도 한다.

**C,C++ 등등: 컴파일러**
초기 AT&T C++ 컴파일러는 소스코드를 c언어로 파싱 -> c 컴파일러로 컴파일 과정을 거침

**JAVA: 중간모델**
자바나 코틀린 같은 경우, 컴파일을 하면 JVM(Java Virtual Machine)이 이해할 수 있는 바이트코드(P-code:precompiled code)로 바뀌어, 가상머신 위에서 프로그램이 실행되면 JVM이 바이트코드를 내부에서 처리하는 형태의 바이트코드 컴파일러를 사용한다.

**PYTHON: 인터프리터**

###### JIT 컴파일러
C나 C++에서 하는 것처럼 프로그램을 실행하기 전에 처음 한 번 컴파일하는 대신, 프로그램을 실행하는 시점에서 필요한 부분을 즉석으로 컴파일하는 방식을 JIT 이라고 한다. 보통 인터프리터 방식의 언어 구현들이 성능 향상을 목적으로 도입하는 경우가 많은데, JIT 컴파일러는 같은 코드를 매번 해석하는 대신 처음 실행될 때 인터프리트를 하면서 자주 쓰이는 코드를 캐싱한 뒤, 이후에는 캐싱된 코드를 가져다 쓰기 때문에 인터프리터의 느린 실행 속도를 개선할 수 있다. 따라서 사실 JIT '컴파일러'보다는 JIT '인터프리터'가 더 정확한 표현이다. 바이트코드 컴파일을 사용하는 Java도 바이트코드를 기계어로 번역할 때 JIT 컴파일러를 사용한다. 프로그램 구동시 소스 코드(혹은 바이트코드)를 실행 단계에서 컴파일하는 데에 시간과 메모리를 소모하기 때문에 정적 컴파일된프로그램에 비해 실행 속도 면에서 손해를 보게 된다. 크게 나눠서 HotSpot VM과같이 메소드(함수) 단위로 JIT 컴파일을 하는 방식과, 그보다 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하며 컴파일 할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 특히 Tracing JIT의 경우에는 실행 시점에만 알 수 있는 정보를 컴파일에 적극적으로 반영하기 때문에 이론적으로는 정적 컴파일 방식보다 더 빨라질 수도 있다. LISP, Java HotSpot VM, NET CLR (C# 등의 .NET Framework 계열 언어), LLVM, LuaJIT (Lua), PHP 8.0, PyPy (Python), TraceMonkey, V8, 차크라코어 (JavaScript), Dalvik VM (Java, 안드로이드)[5], 플래시 (액션스크립트 3.0), Julia, MATLAB, SQL (Prepared Statement 사용 한정) 등이 Jit 컴파일러를 지원한다.

###### 네이티브 컴파일러
C언어의 경우 고급 언어를 컴파일 시 각 기계의 네이티브(cpu, 운영체제)에 맞는 실행 코드로 번역하여 기계어로 만드는 네이티브 컴파일러를 사용한다.

###### 크로스 컴파일러
다른 cpu나 운영체제에서 작동하는 실행코드를 만들기 위하는 컴파일러로 크로스 컴파일러가 있는데, 안드로이드나 아이폰에서 구동할 앱을 위해 윈도우, iMac에서 swift나 kotlin으로 개발하는 것, 리눅스에서 ARM 전용 임베디드 시스템 커널을 구현하기 위해 ARM용 gcc를 사용하는 것 등이 모두 크로스컴파일러에 해당된다.

##### 폰노이만 <-> 함수형
폰노이만: 대입하는언어(스크립트포함)... (a=i);
함수형언어: 함수 호출형 언어 (a.append(i));

## 언어 분석

###### 어휘(토큰) 분석
공백(탭, 스페이스) 제외한 모든 단어나 기호 (엔터는 불확실)
종류: 기호, 키워드, 숫자, 문자열, 이름

##### 구문 분석
변수 타입, 변수 이름, 초기화 부분
함수 몸체부 : 문장의 연속

###### 파스 트리
프로그램의 구조와 각 부분의 역할을 나타내는 트리
언어의 구문을 기술하는 방법 : Context-Free Grammar
파서(AST)가 하는 일: 토큰의 순서와 규칙을 점검

##### 의미 분석
이름의 올바름을 분석과 검사
동일한 이름인지 판별하고 여러 번 나오는 경우 일관되게 사용되고 있는지 검사함
타입 검사 : 수식이나 매개변수, 이름 등이 맞는 타입인가
심볼 테이블 (Symbol Table)
모든 이름에 대해 관련 정보를 모아 놓은 테이블
타입, 구조/크기, 범위
의미분석 -> 의미 오류 검사
* C 언어
 * 의미분석 단계에서 검사되는 의미 규칙 예
 * 모든 이름은 사용되기 전에 반드시 선언되어야 함
 * Undefined name 오류
 * 같은 이름은 범위 안에서는 한번만 사용되어야 함
 * Redefined name 오류
 * 이름은 타입에 맞게 사용되어야 함
 * 타입 오류: int를 배열이 필요한 자리에 넣거나
 * 배열인덱스에 소수점수가 나타남
 * 구조체가 아닌 것에 점이나 화살표를 붙임
 * 함수 호출은 선언부와 일치해야 함
 * 매개변수 개수와 타입이 맞지 않음
 * 반환값이 반환형에 일치해야 함
 * 반환값의 타입이 반환형과 다른 경우

###### 코드 생성기
심볼 테이블 이용 변수 주소 할당
중간 표현을 검사하면서 기계어 명령문을 생성
변수의 참조를 위하여 로드 또는 저장 (레지스터 <-> 메모리)
비교 또는 수식 연산 명령문을 생성
검사에 의한 점프 명령문 생성 (점프할 위치의 레이블 생성)

###### 코드 개선 또는 최적화(Optimization)
프로그램을 동일한 결과를 보장하면서 더 효율적으로 동작
하는 버전으로 변환함
효율성 : 속도 개선 및 메모리 절약
* 코드 개선의 단계
 * AST 상태에서 코드개선
 * 코드 생성 이후 최적화
 * 기계 독립적인 최적화
 * 기계 의존적인 최적화

**코드생성 전 AST 상태에서 코드 개선**
코드의 의미에 따라 성능 개선이 가능한 변경
* AST 상태의 코드 개선방법 예
 * 공통수식 부분 : 같은 계산이 반복되면 결과를 임시값으로 저장했다가 그대로 사용
 * 불필요한 계산 : 계산 결과가 쓰이지 않으면 계산할 필요 없다
 * 연산 바꾸기 : 곱하기 2는 좌측쉬프트, 나누기 2는 우측쉬프트로 바꾼다 (효율적인 연산으로 변경)
 * 루프 불변식 : 루프 안에서 루프와 상관없는 계산이 있으면 루프 밖으로 꺼낸다

**기계 독립적 코드 개선**
특정 기계어 코드의 특성에 상관없이 수행되는 코드개선
변수의 불필요한 load/store를 모두 제거 – 레지스터에 그대로 두고 그 값을 그냥 사용
명령문 스케쥴링
데이터가 로드되기를 기다리는 동안 다른 명령문을 먼저 수행

**기계 의존적 코드 개선**
기계의 특성이나 명령문의 성질을 이용하는 최적화
특정 패턴을 이용한 코드 전체의 분석 방법
행렬 계산이나 플로팅포인트 계산에 특화된 명령문이 있는 경우
그것을 사용하도록 생성된 명령문을 대치
이상의 코드 개선과정을 통해 종종 사람이 직접 작성
한 어셈블리 프로그램보다 더 나은 코드를 만들 수 있다.

###### 프로그램에서 다음 사항들이 결정되는 시점을 쓰시오.

```c
    int a = 123b;
```

> 어휘분석 - 이름

```c
    if(a = = 0)
```

> 구문분석

```c
    a = 5#4
```

> 어휘분석 - 기호

    선언되지 않은 이름이 사용됨

> 의미분석 - 이름

    같은 이름이 두 번 선언됨

> 의미분석 - 이름

    {...괄호가 닫히지 않음

> 구문분석

    int형 변수에 double형 값을 지정

> 의미분석 - 타입

    매개변수 개수가 맞지 않음

> 의미분석 - 매개변수

    초기화되지 않은 변수를 수식에 사용

> 실행시점

    객체의 private 필드를 접근

> 의미분석

    0으로 나누기

> 실행시점

## 바인딩(Binding)

##### 정의
속성과 개체 사이 또는 연산과 기호 사이와 같은 연관(Association)
이름을 속성에 연관(bind)시키는 과정

###### 바인딩 시간(Binding Time)
바인딩이 일어나는 시간

###### 컴파일 시간
컴파일 언어의 원시 프로그램에 사용된 변수의 수명을 결정한다.

###### 연계시간(Linkage Edit)
주프로그램에서 부프로그램으로 연결해야 할 변수들의 기억장소의 주소 등을 결정한다.

###### 적재(Load) 시간
실행 가능한 프로그램이 Loader에 의해 기억장소에 적재될 때 각 변수에 해당하는 기억장소가 할당된다.

##### 정적 바인딩 (Static Binding)
컴파일 바인딩, 번역시간 바인딩, 이른 바인딩(early binding)

##### 언어 설계 시간
* c언어

```c
    int count;
    count = count + 5;
```

> (count에 대해 가능한 자료형 전부 바인딩(int, char, long, float ...))
> (리터럴 5의 내부 표현 (00000101))

##### 언어 구현시간
* c언어

```c
    int count;
    count = count + 5;
```

> (+에 대해 가능한 의미의 집합)
> 컴파일러 설계시간

* c언어

```c
    int count;
    count = count + 5;
```

> (count가 가질 수 있는 값들의 집합 바인딩 (int형 범위))
> 언어 구현 + 컴파일러 설계시간은 보통 묶어서 언어 구현 시간으로 친다.

##### 컴파일 시간(compile)
* c언어

```c
    int count;
    count = count + 5;
```

> (count에 해당하는 자료형 바인딩 (int), +가 해당하는 의미 바인딩 (수치)

##### 링크 시간(link)
> 라이브러리 (stdio.h) 등을 호출

##### 로드 시간(load)
* c언어

```c
    int count;
    count = count + 5;
```

> (변수 count에 대한 메모리 값을 할당 )

###### 동적 바인딩 (Binding Time)
실행시간 바인딩, 늦은 바인딩(late binding)
> 언어 설계, 언어 구현, 컴파일, 링크, 로드
> 결정되는 것 : 변수의 수명, 기억 공간 크기, 자료구조

##### 실행 시간
 * c언어

```c
    int count;
    count = count + 5;
```

> (count의 값이 주소에 바인딩된다.)

* 자바스크립트

```javascript
    count = 5;
```

> (실행과 동시에 count의 자료형이 정해진다)

* 그 외

> virtual function(가상 함수) table

**정적 바인딩과 동적 바인딩은 실행시간을 기점으로 나뉜다.**

###### 정적 오류
컴파일러 오류

###### 동적 오류
실행 오류

###### 프로그램에서 다음 사항들이 결정되는 시점을 쓰시오.
①바인딩 생성 ②바인딩 사용 ③바인딩해지 ④객체생성 ⑤객체해지
1) (자바)힙 객체의 생성과 바인딩 순서 m = new M();
2) 지역변수 객체의 생성과 바인딩 순서 int n;
3) 매개변수로 전달된 참조변수의 생성과 바인딩 순서 void f(M m);

###### 프로그램에서 다음 사항들이 결정되는 시점을 쓰시오.
(1) 언어 정의시간 (2) 언어구현시간 (3) 번역시간 (4) 실행시간

    데이터의 기본타입

> 언어 정의 시간

    정수의 자릿수 (데이터 크기)

> c언어: 언어 구현 시간, java: 언어 정의 시간

    지역변수의 할당 순서

> 번역 시간

    동적 할당된 객체의 주소

> 실행 시간

    함수가 언제 호출될지

> 실행 시간

## 프로그램 구조

###### 컴파일 시간 상수
컴파일 시간에 결정됨 (#define 포함)
* java의 경우 빌트인 함수나 연산을 이용한 수식은 가능함

```java
 * const int MAX = 100; // C
 * final int MaxSize = 100; // Java
 * final double MinVal = Math.sqrt(MaxSize);
```
###### 실현 시간 상수
실행 중 처음 결정되어 바뀌지 않음

###### 정적 객체
정적 영역에 있는 개체(값이 바뀌지 않음을 의미하지 않는다)
프로그램 종료 전까지 할당된 주소가 변하지 않는 객체
컴파일 상수의 경우, 메모리가 할당되지 않으므로 객체가 생성되지 않는다 그러므로 정적 객체x
static은 호출한 시점에 메모리 할당이 되고 프로그램 종료시 할당 해제

참고 [외부 Blog]:https://namoeye.tistory.com/entry/%EC%A0%95%EC%A0%81%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%A2%85%EB%A5%98

###### 북키핑
프레임(스택 프레임)을 설정해주는것을 북키핑이라고도 함

##### 힙
속도와 공간의 균형, 공간 문제

###### 내부 단편화 (Internal fragmentation)
사용하는 공간보다 과도하게 큰 공간 할당시 나머지 공간이 낭비된다

###### 외부 단편화 (External fragmentation)
남아있는 공간이 단편화되어 충분한 공간에 할당을 못하게 된다

###### 자유블럭(free block) 리스트
현재 쓰이지 않는 힙 블록의 링크 리스트
처음에는 전체 힙이 하나의 블록으로 존재
각 할당 요청에 대해 리스트를 검색하여 적당한 블록을 찾음

###### 우선 할당
우선순위 이용

###### 최적 할당
남는 부분이 제일 적은 블록을 찾음

###### 검색 시간
자유 블록의 개수에 선형 비례함
크기 별로 자유 블록 리스트를 별도로 유지함
동적 풀을 관리
 * 크기 별로 유지하는 방법
  * 버디 시스템 : 크기가 2의 제곱인 블록으로 유지, 할당될 때 해당 크기가 없으면 바로 위 크기를 반으로 쪼갬, 해지될 때 가능하다면 합쳐서 큰 블록으로 유지
  * 피보나치 힙 : 피보나치 수를 사용함, 약간 더 복잡하지만 내부 단편화가 약간 적음
  
  
  
  
  
  
  
각각에 해당하는 바인딩 시점을 보기에서 고르시오.
<보기> (A) 언어설계 (B) 언어구현 (C) 컴파일 (D) 링크 (E) 로드 (F) 실행
(a) 지역변수의 오프셋
(b) 다른 파일에서 선언된 전역변수의 주소
(c) 오버플로우가 일어났을 때 처리 방법
(d) 복합 타입의 종류와 만드는 방법
(e) 함수 호출 순서
(f) 전역변수의 실제주소(PA)
